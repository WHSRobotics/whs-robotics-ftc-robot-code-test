#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     SMUXER,         sensorI2CCustom9V)
#pragma config(Sensor, S4,     ttGyroNXT,      sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorA,          ttMot,         tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     ttMot2,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     sweBL,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     sweFR,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     sweFL,         tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C1_1,    swiFR,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    swiFL,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    swiBR,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    swiBL,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "hitechnic-sensormux.h"
#include "hitechnic-gyro.h"
//#include "gyro_header1.h"


const float MILLISECOND = 1000.0; //number of milliseconds in one second
const float DEFAULT_VAL = 42.0; //generic value for initialization that's greater than 0
const float ADJUST_M = 1.0; //slope of linear equation to scale target angle
const float ADJUST_B = 7.0; //y-intercept of linear equation to scale target angle
const float TURN_THRESHOLD = 1.0; //stop turning when <1 degree left to turn
float currentValue = 0.0; //current value of adjusted gyro reading (w/o BIAS)
float angleChange = 0.0; //amt of change in angle turned
float timeChange = 0.0; //amt of change in time (sec)
float gCurrTotalMove = 0.0; //amt turned already
float sCurrTotalTurn = 0.0; //amt of turn in moveStraight
float remainingTurn = DEFAULT_VAL; //amt of turn remaining
float error = 0.0;
float gyroReading = 0.0; //gyro reading WHAT IS THIS VARIABLE FOR
float adjustedTarget = 0.0; //adjusted amt of turn remaining

//const tMUXSensor ttGyro = msensor_S1_1;
const tMUXSensor dtGyro = msensor_S1_2;
const float JOY2ANGINC = 45.0/128.0; //convert joy to ang inc
const float JVAL2POW = 0.78125; //100.0/128.0; convert joy val to pwr
const float ANG2SERVO = 15.25/180.0;//for giant servos, but 256.0/180.0; for standard
const float SERVO2TIME = 2.0; //20.0/10.0; convert servo val to Msec
const float POS_PIV = 45.0*ANG2SERVO;
const float NEG_PIV = 135.0*ANG2SERVO;
//tGyro ttGyro;
bool isTurning = false;
//same concept as drive train rotation

//if negative x, turn CCW
//if positive x, turn CW
//power is always 100
//angle increment is proportional to |x|
//need gyro limit: account for gyroRobot addition.



/***************************************
**  gyroCenterPivot turns the robot   **
**  accurately using the gyro sensor. **
**  Turns at a certain speed until it **
**  gets to turnDirection.            **
*--------------------------------------*
* Parameters:
* int turnDirection - Num degrees to turn to
* int speedKonstant - Speed to turn at
****************************************/
/*void gyroTTTurn(tGyro gyro, float finalAng, float pwr)
{
//Initialization
calibrateGyro(gyro);

gyro.adjustedTarget = gyro.ADJUST_M * finalAng - gyro.ADJUST_B; //scale target angle linearly

do
{
updateTurn(gyro, pwr);

//apply calculated turn pwr to DT motors
///motor[ttMot] = gyro.turn;
writeDebugStreamLine("%d",gyro.turn);

wait10Msec(1);
}
while(abs(gyro.remainingTurn) > gyro.TURN_THRESHOLD); //while significantly turning

motor[ttMot] = 0;
resetGlobalVars(gyro);
}*/

/**************************************
** resetGlobVars resets the global   **
** variables to their initial values **
** for gyro-dependent turn functions **
***************************************/
void resetGlobVars()
{
	currentValue = 0.0;
	angleChange = 0.0;
	timeChange = 0.0;
	gCurrTotalMove = 0.0;
	sCurrTotalTurn = 0.0;
	remainingTurn = DEFAULT_VAL;
	error = 0.0;
	adjustedTarget = 0.0;
}


/**************************************
**  getAngleChange gives an updated  **
**  change in angle                  **
***************************************/
float getAngleChange()
{
	currentValue = HTGYROreadRot(ttGyroNXT);//gyroReading - BIAS;
	timeChange = time1[T1]/MILLISECOND; //change in time (sec)

	ClearTimer(T1);

	angleChange = currentValue * timeChange;
	return angleChange;
}


/*****************************************
**  getCurrTotalMove gives a current    **
**  running total of turn for the gyro  **
******************************************/
float getCurrTotalMove(float currTotal)
{
	currTotal += getAngleChange();
	return currTotal;
}


void gyroCenterPivot(float turnDirection, float speedKonstant)
{
	//Initialization
	HTGYROstartCal(ttGyroNXT); //Calibrate gyro sensor
	ClearTimer(T1);

	adjustedTarget = ADJUST_M * turnDirection - ADJUST_B; //scale target angle linearly
	float turn = 100.0;  //default pwr for drive train motors

	do
	{
		remainingTurn = adjustedTarget - gCurrTotalMove; //find # of degrees left to turn
		gCurrTotalMove += getAngleChange();
		error = adjustedTarget - gCurrTotalMove;
		turn = error * speedKonstant; //find pwr for DT motors

		//apply calculated turn pwr to DT motors

		motor[ttMot] = -turn;
		//writeDebugStreamLine("%d",remainingTurn);

		wait1Msec(10);
	}while(abs(remainingTurn) > 1.0); //while significantly turning

	motor[ttMot] = 0;
	PlayTone(440,30);
	//stopDriveTrain();
	resetGlobVars();
}

	float dth_dt = 0.0;
	float u = 0.0;
	float mean_reading = 0.0;
	float th = 0.0;
	float dt = 0.010;

task gyro()
{
	mean_reading = HTGYROstartCal(ttGyroNXT);
	while(true)
	{
		u =   SensorRaw[ttGyroNXT];
		wait1Msec(2);
    u = u+SensorRaw[ttGyroNXT];
		dth_dt = u/2.0 - mean_reading;
		mean_reading = mean_reading*0.999 + (0.001*(dth_dt+mean_reading));
		th = th + dth_dt*dt;

		//WAIT THEN REPEAT
		while(time1[T4] < dt*1000.0)
		{
			wait1Msec(1);
		}
		ClearTimer(T4);
	}
}


task main()
{
//initGlobalVars(ttGyro, ttGyroNXT);
/*float angTotal = 0.0;
bool posMove = false;
bool negMove = false;
HTGYROstartCal(ttGyroNXT);

waitForStart();

StartTask(gyro);
while(true)
{
	getJoystickSettings(joystick);
	float motPow = joystick.joy1_x1*JVAL2POW;
	posMove = (joystick.joy1_x1 > 10.0 && th <= 45.0);
	negMove = (joystick.joy1_x1 < -10.0 && th >= -45.0);
	if(posMove || negMove)
	{
		//angTotal += th;
		writeDebugStreamLine("%f",th);
		motor[ttMot] = motPow;
	}
	else
	{
		motor[ttMot] = 0;
	}
	wait1Msec(20);
	resetGlobVars();
	//gyroTTTurn(ttGyro,angInc,5);
}*/
nMotorEncoder[ttMot] = 0;
nMotorEncoderTarget[ttMot] = 0;
motor[ttMot] = -10;
ClearTimer(T1);
while(nMotorEncoder[ttMot] > -360)
{
writeDebugStreamLine("%f",time1[T1]/1000.0);}
motor[ttMot] = 0;

writeDebugStreamLine("FINAL: %f",time1[T1]/1000.0);

}
