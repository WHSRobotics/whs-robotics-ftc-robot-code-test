#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     touchSensor,    sensorTouch)
#pragma config(Sensor, S3,     IRSensor,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     gyroSensor,     sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorA,          rightIntake,   tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftIntake,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     leftDrive,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     rightDrive,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     leftArm,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     rightArm,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     hang1,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     hang2,         tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C4_1,    flagServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    autoServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    intakeServo,          tServoStandard)
#pragma config(Servo,  srvo_S1_C4_5,    hangServo1,           tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    hangServo2,           tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

////////////////////////INCLUDES////////////////////
//#include "JoystickDriver.c"; //driver for receiving bluetooth msgs
#include "arps_functions1.h"; //header file for ARP Functions

bool finishIR = false;
bool needArmUp = false;

//////////////////INITIALIZATION//////////////////
void initArr()
{
	//initializing tally array
	for(int count = 0; count < 4; count++)
	{
		tally[count] = 0;
	}
}

void initializeRobot()
{
  //resetArm();
  resetHang(); //hang arm
  resetBucket(); //DO NOT reset the NXT motors!!

	//reset drive train encoders
	nMotorEncoder[leftDrive] = 0;
	nMotorEncoder[rightDrive] = 0;

	//---------------------------------------------------HTGYROstartCal(gyroRobot); //calibrate gyro
	//--------------------------------------------------- //read IR

	//clear timers T1 and T2
	ClearTimer(T1);
	ClearTimer(T2);

	//beep to signal end of initialization
	PlayTone(440, 30);

  return;
}


//////////////////FUNCTIONS///////////////////
/*void moveArm(int power)
{
	motor[leftArm] = power;
	motor[rightArm] = power;
}
*/
void tallyIR()
{
	currIR = SensorValue[IRSensor];//update current IR reading;
	if(currIR <= thresh[0]) //position 1
	{
		tally[0]++;
	}
	else if(currIR <= thresh[1]) //position 2
	{
		tally[1]++;
	}
	else if(currIR <= thresh[2]) //position 3
	{
		tally[2]++;
	}
	else if(currIR >= thresh[3]) //position 4
	{
		tally[3]++;
	}
}

int checkTally()
{
   int max = -50; //arbitrary negative number for initialization
   int maxIndex = -1; //arbitrary negative number for initialization
   for(int count = 0; count < 4; count++)
   {
			if(tally[count] > max)
			{
			   max = tally[count];
			   maxIndex = count;
			}
   }
   return maxIndex;
}


////////////////////TASKS/////////////////////
task IR()
{
	while(!finishIR)
	{
		tallyIR();
		wait1Msec(250);
	}
}

task Arm()
{
	while(true)
	{
		if(needArmUp)
		{
			moveArm(80);
			wait1Msec(1000);
			moveArm(0);
			needArmUp = false;
		}
	}
}


/////////////////////MAIN//////////////////////

task main
{
	//initializeRobot();

//	waitForStart();

//	StartTask(IR);
	//   move straight forward a bit
	//moveStraight(6.0, 100);

	finishIR = true;

	while(true)
	{
		int bob = SensorValue[IRSensor];
		nxtDisplayString(3,"%d",bob);

	}
}
