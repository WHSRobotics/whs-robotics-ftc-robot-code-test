#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     excel,          sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     leftDrive,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     rightDrive,    tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#include "hitechnic-accelerometer.h";
#include "ExcelDriver.h";

int min = 100; //arbitrary number greater than 0 for initialization
bool hit = false;
float time = 0;
/*	int excel_x_raw = 0;
	int excel_y_raw = 0;
	int excel_z_raw = 0;
	float excel_x = 0.0;
	float excel_y = 0.0;
	float excel_z = 0.0;
	const float GRAVY = 4.903325; //cm/s^2
	float y = 0.0;                // create and set 'y' to 0.0
	float LCD_width = 100.0;      // create and set 'LCD_width' to 100.0 (width of NXT LCD in pixels)
*/
/*task yValue()
{
	while(true)
	{
		HTACreadAllAxes(excel,excel_x_raw,excel_y_raw,excel_z_raw); // calculate y-coordinate of pixel to draw
		excel_y = excel_y_raw;
		excel_z = excel_z_raw;
		excel_x = excel_x_raw;
		eraseDisplay();
		nxtDisplayString(1,"x: %d", excel_x*GRAVY);
		nxtDisplayString(2,"y: %d", excel_y*GRAVY);
		nxtDisplayString(3,"z: %d", excel_z*GRAVY);
		wait1Msec(25);
	}
}

task Display()
{
	while(true)
 	{
		nxtDrawLine(0, 31, 99, 31);   // draw a line across the center of the LCD
 		excel_y = excel_y_raw*GRAVY;

		for(int x = 0; x < 100; x++)  // loop from 0 to 99
		{
		  HTACreadAllAxes(excel,excel_x_raw,excel_y_raw,excel_z_raw); // calculate y-coordinate of pixel to draw
		  excel_y = excel_y_raw*GRAVY;

		  if(abs(excel_y) > 3)
		  {
		  	if(excel_y > 0)
		  	/*{
		  		PlayTone(500,1);
		  	}
		  	else
		  	{
		  		PlayTone(300,1);
		  	}*/
		  	/*PlayTone(excel_y*5.0+300,1);
		  }
		  nxtSetPixel(x, 0.5*excel_y + 31);                   // draw pixel at (x, y+31)
		}
		eraseDisplay();
	}
}*/


task Graph()
{
	while(true)
	{

		nxtDrawLine(0, 31, 99, 31);   // draw a line across the center of the LCD

		for(int x = 0; x < 1000; x++)  // loop from 0 to 99
		{
			updateExcel();
			nxtSetPixel(x, excel_y*20.0 + 31);
		}
		eraseDisplay();
	}
}


task Values()
{
	while(true)
	{
		updateExcel();
		displayValues();
	}
}


task FindMinimum() //time in 100-Msec
{
	ClearTimer(T2);

	while(time100[T2] < time*0.2)
	{} //do nothing
	while(time100[T2] < time*0.8)
	{
		updateExcel();
		if(excel_y < min)
		{
			min = excel_y;
		}
		if(min < -6) //threshold
		{
			PlayTone(440,1);
			hit = true;
		}
	}
	while(true)
	{
		nxtDisplayString(1,"min: %d", min);
		if(hit)
		{
			nxtDisplayString(2,"hit: true");
		}
		else
		{
			nxtDisplayString(2,"hit: false");
		}
	}
}


void cosRampMove(float maxPwr, float time)
{
	float firstPwr = 0.0;
	float secondPwr = 0.0;

	float amplitude = maxPwr/2.0 - 5.0;

	ClearTimer(T1);

	while(time100[T1] <= time/4.0)
	{
		firstPwr = -amplitude*cos((4.0*PI*time100[T1])/time)+amplitude+10.0;
		motor[leftDrive] = firstPwr;
		motor[rightDrive] = firstPwr;
	}
	while(time100[T1] <= time)
	{
		secondPwr = -amplitude*cos((4.0*PI*time100[T1])/(3.0*time)+(2.0*PI)/3.0)+amplitude+10.0;
		motor[leftDrive] = secondPwr;
		motor[rightDrive] = secondPwr;
	}

	motor[leftDrive] = 0;
	motor[rightDrive] = 0;
}

task main()
{
	time = 15;
	initializeExcel();
	//StartTask(Graph);
	StartTask(Values);
	//StartTask(Display);
	//StartTask(yValue);
	StartTask(FindMinimum);
	cosRampMove(100.0,time);
	while(true){};
}
