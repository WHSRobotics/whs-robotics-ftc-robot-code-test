#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S3, HTServo,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     sweBL,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     sweFL,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     sweBR,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     sweFR,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorK,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S3_C1_1,    swiFR,                tServoStandard)
#pragma config(Servo,  srvo_S3_C1_2,    swiBR,                tServoStandard)
#pragma config(Servo,  srvo_S3_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_6,    servo6,               tServoNone)
#pragma config(Servo,  srvo_S3_C2_1,    swiFL,                tServoStandard)
#pragma config(Servo,  srvo_S3_C2_2,    swiBL,                tServoStandard)
#pragma config(Servo,  srvo_S3_C2_3,    servo9,               tServoNone)
#pragma config(Servo,  srvo_S3_C2_4,    servo10,              tServoNone)
#pragma config(Servo,  srvo_S3_C2_5,    servo11,              tServoNone)
#pragma config(Servo,  srvo_S3_C2_6,    servo12,              tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

const int HI_THRESH = 25;
const int LOW_THRESH = 15;
const float JOY_MAP = 0.78125;
const float SERVO_MAP = 15.25/PI;
const float ROT_SCALE = 0.01;
const float SPEED_SCALE = 0.5;
const float HALF_WIDTH_X = 6.8125;
const float HALF_LENGTH_Y = 7.125;
//PIVOT CODE VARS
/*const float JVAL2POW = 0.78125; //100.0/128.0; convert joy val to pwr
const float ANG2SERVO = 15.25/180.0;//for giant servos, but 256.0/180.0; for standard
const float SERVO2TIME = 2.0; //20.0/10.0; convert servo val to Msec
const float POS_PIV = 45.0*ANG2SERVO;
const float NEG_PIV = 135.0*ANG2SERVO;
bool isPivoting = false;
float preVals[4]; //values of servos before pivot pos
TServoIndex swiArr[4];*/
//END PIVOT CODE VARS

float magValue = 0.0;
float swervePow = 0.0;
float angle = 0.0;
float servoPos = 0.0;

//----ARCADE_DRIVE_CONFIG----//
//Joystick1: Angle and Velocity
//Joystick2: Rotation

//----TANK_DRIVE_CONFIG----//
//Joystick1: Side One
//Joystick2: Side Two

//----TEST_TO_DO_LIST----//
//0. Check if stuff works by thinking how it would process it, check domains ranges, and all that stuff
//DATATYPES CONSISTENCY CHECK
//INSIDE OUTSIDE ROBOT TURNING CENTER
//1. Add proportionality constants for tank drive
//2. Integrate Priority Controls for Tony and Lawrence
//3. DONE Modify code for servos if we are using 3 rotation servos
//4. Integrate Compass sensor correction function
//5. Consider Basic Semaphore systems
//6. Update Notes list
//7. Arm program if up keep running nxt motors, if down toggle

//----FUNCTIONS----//

/*
float arctan(float y, float x)
{
	if(atan2(y, x) < 0)
	{
		return atan2(y, x) + PI;
 	}
	else
	{
		return atan2(y, x);
	}
}
*/

//PIVOT CODE FUNCTIONS
/*
void setServoArr()
{
	//go by unit circle
	swiArr[0] = swiFR;
	swiArr[1] = swiFL;
	swiArr[2] = swiBL;
	swiArr[3] = swiBR;
}

void setPreVals()
{
	for(int i = 0; i < 4; i++)
	{
		preVals[i] = ServoValue[swiArr[i]];
	}
}


void setPivPos()
{
	//orientation:
	//   /----\
	//   ------
	//   \----/

	setPreVals();

	servo[swiFL] = POS_PIV;
	servo[swiBR] = POS_PIV;
	servo[swiFR] = NEG_PIV;
	servo[swiBL] = NEG_PIV;
}


void undoPivPos()
{
	for(int i = 0; i < 4; i++)
	{
		servo[swiArr[i]] = preVals[i];
	}
}

void setAllMot(float pwr)
{
	motor[sweFR] = pwr;
	motor[sweFL] = pwr;
	motor[sweBL] = pwr;
	motor[sweBR] = pwr;
}


int getPivWait()
{
	float diff = 0.0;
	float max = -10.0; //arbitrary negative number for initialization

	//Find the greatest servo pos change needed
	for(int i = 0; i < 4; i++)
	{
		if(i % 2 != 0)
			diff = abs(POS_PIV - preVals[i]);
		else
			diff = abs(NEG_PIV - preVals[i]);
		if(max < diff)
			max = diff;
	}

	//Convert to Msec
	return max*SERVO2TIME;
}

//END PIVOT CODE*/

float magnitudeCalc(float inputX, float inputY)
{
	return sqrt( pow(inputX, 2) + pow(inputY, 2) );
}

//-EDIT- servo upper and lower bound functions.  add scaler
void piMotor(tMotor motorName, TServoIndex servoName, float inputY, float inputX, float initServoPos)
{
	if((magnitudeCalc(inputY, inputX) > LOW_THRESH) && (magnitudeCalc(inputY, inputX) <= 128.0))
	{
		if(atan2(inputY, inputX) < 0)
		{
			servo[servoName] = (atan2(inputY, inputX) + PI) * SERVO_MAP + initServoPos;
			motor[motorName] = -magnitudeCalc(inputY, inputX) * JOY_MAP;
		}
		else
		{
			servo[servoName] = atan2(inputY, inputX) * SERVO_MAP + initServoPos;
			motor[motorName] = magnitudeCalc(inputY, inputX)* JOY_MAP;
		}
	}
	else
	{
		servo[servoName] = PI/2.0 * SERVO_MAP + initServoPos;
		motor[motorName] = 0;
	}
}

//-EDIT-Pairs swivel servos for tank drive capability
/*void swivelSymmetric(float angleOne, float angleTwo)
{
	servo[swiFL] = PI/2.0 + angleOne;
	servo[swiBL] = PI/2.0 - angleOne;
	servo[swiFR] = PI/2.0 + angleTwo;
	servo[swiBR] = PI/2.0 - angleTwo;
}

//-EDIT-Pairs motor powers together for tank drive
void powerPair(float powerOne, float powerTwo)
{
	if( (abs(powerOne) > LOW_THRESH) || (abs(powerTwo) > LOW_THRESH) )
	{
		motor[sweFL] = powerOne;
		motor[sweBL] = powerOne;
		motor[sweFR] = powerTwo;
		motor[sweBR] = powerTwo;
	}
	else
	{
		motor[sweFL] = 0;
		motor[sweBL] = 0;
		motor[sweFR] = 0;
		motor[sweBR] = 0;
	}
}
*/

//-CONSISTENCY-Swivel Direction aligns all swivel servos to the same angle
void swivelDirection(float angle)
{
	servo[swiFL] = angle;
	servo[swiBL] = angle;
	servo[swiFR] = angle;
	servo[swiBR] = angle;
}

//Run Power outputs power from the joystick with built in threshold//
void runPow(float power)
{
	if(abs(power) > LOW_THRESH)
	{
		motor[sweFL] = power;
		motor[sweBL] = power;
		motor[sweFR] = power;
		motor[sweBR] = power;
	}
	else if (abs(power) > 100)
	{
		motor[sweFL] = power/abs(power) * 100;
		motor[sweBL] = power/abs(power) * 100;
		motor[sweFR] = power/abs(power) * 100;
		motor[sweBR] = power/abs(power) * 100;
	}
	else
	{
		motor[sweFL] = 0;
		motor[sweBL] = 0;
		motor[sweFR] = 0;
		motor[sweBR] = 0;
	}
}

//-EDIT-
//Symmetric Swivel aligns swivel servos in a reflectionally symmetric way along the horizontal axis of the robot//
//Used for tank Drive and Rotation in swerve Drive//
void swerveDiffRun(float joyValOne,float joyValTwo, float halfWidth)
{
	float radiusOne = joyValOne * JOY_MAP;
	float radiusTwo = joyValTwo * JOY_MAP;
	float angleOne = atan2(halfWidth, sqrt( pow(radiusOne, 2) - pow(halfWidth, 2) ) );
	float angleTwo = atan2(halfWidth, sqrt( pow(radiusTwo, 2) - pow(halfWidth, 2) ) );
	//swivelSymmetric(angleOne, angleTwo);
}

//this function does swerve, no scalers yet
void swerveControl(float transXInput, float transYInput, float angularInput)
{
	//scaler for end result (max power)
	float angSclr = angularInput * ROT_SCALE;
	float transXSclr = transXInput * SPEED_SCALE;
	float transYSclr = transYInput * SPEED_SCALE;
	float velFLX = angSclr * HALF_LENGTH_Y + transXSclr;
	float velFLY = angSclr * -HALF_WIDTH_X + transYSclr;
	float velBLX = angSclr * -HALF_LENGTH_Y + transXSclr;
	float velBLY = angSclr * -HALF_WIDTH_X +  transYSclr;
	float velFRX = angSclr * HALF_LENGTH_Y + transXSclr;
	float velFRY = angSclr * HALF_WIDTH_X +  transYSclr;
	float velBRX = angSclr * -HALF_LENGTH_Y + transXSclr;
	float velBRY = angSclr * HALF_WIDTH_X + transXSclr;
	//sweFl is 90 degrees out of phase
	piMotor(sweFL, swiFL, velFLY, velFLX, 20);
	//sweBL is 90 degrees out of phase
	//piMotor(sweBL, swiBL, velBLY, velBLX, 40);
	//sweFr is terrible
	//piMotor(sweFR, swiFR, velFRY, velFRX);
	//sweBr is problematic
	//piMotor(sweBR, swiBR, velBRY, velBRX);
}

//In this swerveDrive task, translations take precendence over rotation
task swerveDrive()
{
	while(true)
	{

		getJoystickSettings(joystick);
		if( (joystick.joy1_y1 != 0) && (joystick.joy1_x1 != 0) )
		{
			magValue = magnitudeCalc(joystick.joy1_y1, joystick.joy1_x1);
			swervePow = magValue * JOY_MAP;
			if( joystick.joy1_y1 >= 0 )
			{
				angle = SERVO_MAP * acos(joystick.joy1_x1/128.0);
				swivelDirection(angle);
				runPow(swervePow);
			}
			else
			{
				angle = SERVO_MAP * acos(joystick.joy1_x1/-128.0);
				swivelDirection(angle);
				runPow(-swervePow);
			}
		}
		else
		{
			if(joystick.joy1_x2 > 0)
			{}
			else if(joystick.joy1_x2 < 0)
			{}
			else
			{}
		}
	}
}

task lawrenceFPS()
{
	float pivMotPow = 0.0;

	while(true)
	{
		getJoystickSettings(joystick);
		//PIVOT CODE
		/*if(abs(joystick.joy1_x2*JOY_MAP) > LOW_THRESH)
		{
			motPow = joystick.joy1_x2*JVAL2POW;
			if(!isPivoting)
			{
				isPivoting = true;
				setAllMot(0);
				wait1Msec(100);
				setPivPos();

				wait1Msec(getPivWait());
			}
			setAllMot(pivMotPow);
		}
		else
		{*/
			/*isPivoting = false;
			setAllMot(0);
			undoPivPos();*/
			//END PIVOT CODE

			switch(joystick.joy1_TopHat)
			{
 	 		 	case 0:
   				swivelDirection(PI/2.0);
   				runPow(100);
   				break;

    		case 1:
   				swivelDirection(PI/4.0);
   				break;

   			case 2:
   				swivelDirection(0.0);
   				runPow(100);
    			break;

    		case 3:
   				swivelDirection(0.75*PI);
   				runPow(-100);
   				break;

	  		case 4:
	  			swivelDirection(PI/2.0);
	  			runPow(-100);
    			break;

		  	case 5:
   				swivelDirection(PI/4.0);
   				runPow(-100);
   				break;

		  	case 6:
		  		swivelDirection(0.0);
		  		runPow(-100);
    			break;

		  	case 7:
   				swivelDirection(0.75 * PI);
   				runPow(100);
   				break;

	  		default:
	  			swivelDirection(PI/2.0);
	  			runPow(0);
	  	}
	}
}


task simpleTankDrive()
{
	while(true)
	{
       getJoystickSettings(joystick);
       swivelDirection(PI/2.0 * SERVO_MAP);
       //powerPair(joystick.joy1_y1 * JOY_MAP, joystick.joy1_y2 * JOY_MAP);
	}
}

task complexTankDrive()
{
	while(true)
	{
	}
}

void initializeRobot()
{
	servo[swiFL] = 85;
	servo[swiBL] = 44;
	servo[swiFR] = 52;
	servo[swiBR] = 60;
}
task main()
{
	//PIVOT CODE (put in initialization later)
	//setServoArr();
	//END PIVOT CODE
	//StartTask(lawrenceFPS);
	initializeRobot();
	waitForStart();
	while(true)
	{
		getJoystickSettings(joystick);
		swerveControl(joystick.joy1_y1, joystick.joy1_x1, joystick.joy1_x2);
	}
}
