#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     SMUXER,         sensorI2CCustom9V)
#pragma config(Motor,  motorA,          sweFR,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     sweBR,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     sweBL,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     sweFR,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     sweFL,         tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C1_1,    swiFR,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    swiFL,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    swiBR,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    swiBL,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
const float PINC_SCALE = 0.78125; //100.0/128.0; convert joy val to pwr
const float ANG2SERVO = 15.25/180.0;//for giant servos, but 256.0/180.0; for standard
const float SERVO2TIME = 2.0; //20.0/10.0; convert servo val to Msec
const float POS_PIV = 45.0*ANG2SERVO;
const float NEG_PIV = 135.0*ANG2SERVO;
bool isPivoting = false;
float preVals[4]; //values of servos before pivot pos
TServoIndex swiArr[4];
//drive train rotation

//if negative x, turn CCW
//if positive x, turn CW
//power is incremented within [0,100]
//power increment is proportional to |x|
//need gyro limit: account for gyroRobot addition.

void setServoArr()
{
	//go by unit circle
	swiArr[0] = swiFR;
	swiArr[1] = swiFL;
	swiArr[2] = swiBL;
	swiArr[3] = swiBR;
}

void setPreVals()
{
	for(int i = 0; i < 4; i++)
	{
		preVals[i] = servoValue[swiArr[i]];
	}
}


void setPivPos()
{
	/*orientation:
	 /----\
	 ------
	 \----/
	*/
	setPreVals();

	servo[swiFL] = POS_PIV;
	servo[swiBR] = POS_PIV;
	servo[swiFR] = NEG_PIV;
	servo[swiBL] = NEG_PIV;
}


void undoPivPos()
{
	for(int i = 0; i < 4; i++)
	{
		servo[swiArr[i]] = preVals[i];
	}
}

void setAllMot(float pwr)
{
	motor[sweFR] = pwr;
	motor[sweFL] = pwr;
	motor[sweBL] = pwr;
	motor[sweBR] = pwr;
}


int getPivWait()
{
	float diff = 0.0;
	float max = -10.0; //arbitrary negative number for initialization

	//Find the greatest servo pos change needed
	for(int i = 0; i < 4; i++)
	{
		if(i % 2 != 0)
			diff = abs(POS_PIV - preVals[i]);
		else
			diff = abs(NEG_PIV - preVals[i]);
		if(max < diff)
			max = diff;
	}

	//Convert to Msec
	return max*SERVO2TIME;
}


task main()
{
	setServoArr();
	waitForStart();

	while(true)
	{
		getJoystickSettings(joystick);
		float motPow = joystick.joy1_x2*PINC_SCALE;

		if(abs(joystick.joy1_x2) > 10)
		{

			if(!isPivoting)
			{
				isPivoting = true;
				setAllMot(0);
				wait1Msec(100);
				setPivPos();

				wait1Msec(getPivWait());
			}
			setAllMot(motPow);
		}
		else
		{
			isPivoting = false;
			setAllMot(0);
			undoPivPos();
		}
	}
}
