#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     excel,          sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     leftDrive,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     rightDrive,    tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard   no it wasn't            !!*//
#include "hitechnic-accelerometer.h";



task Display()
{
	//just for y axis for now
	int excel_x_raw = 0;
	int excel_y_raw = 0;
	int excel_z_raw = 0;
	float excel_x = 0.0;
	float excel_y = 0.0;
	float excel_z = 0.0;
	const float GRAVY = 0.0980665; //cm/m^s
	float y = 0.0;                // create and set 'y' to 0.0
	float LCD_width = 100.0;      // create and set 'LCD_width' to 100.0 (width of NXT LCD in pixels)

 	while(true)
 	{
		nxtDrawLine(0, 31, 99, 31);   // draw a line across the center of the LCD
 		excel_y = (excel_y_raw/100.0)/GRAVY;

		for(int x = 0; x < 100; x++)  // loop from 0 to 99
		{
		  HTACreadAllAxes(excel,excel_x_raw,excel_y_raw,excel_z_raw); // calculate y-coordinate of pixel to draw
		  excel_y = (excel_y_raw/100.0)/GRAVY;

		  if(abs(excel_y) > 3)
		  {
		  	if(excel_y > 0)
		  	/*{
		  		PlayTone(500,1);
		  	}
		  	else
		  	{
		  		PlayTone(300,1);
		  	}*/
		  	PlayTone(excel_y*5.0+300,1);
		  }
		  nxtSetPixel(x, 2.0*excel_y + 31);                   // draw pixel at (x, y+31)
		}
		eraseDisplay();
	}
}

void runDrive(float power)
{
	motor[leftDrive] = power;
	motor[rightDrive] = power;
}


//time == Msec
void rampDrive(float maxPwr, float time)
{
	float rampTime = time*0.2; //one ramp time
	float maxPwrTime = time - rampTime*2.0;
	float currPow = 0.0;
	float lineIncrement = maxPwr/rampTime;

	for(float rampUpTime = 0.0; rampUpTime < rampTime; rampUpTime++) //ramp up
	{
		currPow += lineIncrement;
		runDrive(currPow);
		wait1Msec(lineIncrement);
	}
	for(float maxPowTime = 0.0; maxPowTime < maxPwrTime; maxPowTime++) //max pow
	{
		currPow = maxPwr;
		runDrive(currPow);
		wait1Msec(1);
	}
	for(float rampDownTime = 0.0; rampDownTime < rampTime; rampDownTime++) //ramp down
	{
		currPow -= lineIncrement;
		runDrive(currPow);
		wait1Msec(lineIncrement);
	}

	runDrive(0); //stop the drive train
}


void cosExpRamp(float time , float maxPwr)
{
	float maxPwrAmp = maxPwr / 2.0 - 5.0;
	ClearTimer(T1);
	while(time100[T1] <= 25)
	{
		float uPwr = - maxPwrAmp * cos(PI / 25.0 * time100[T1]) + maxPwrAmp + 10.0;
		motor[leftDrive] = uPwr;
		motor[rightDrive] = uPwr;
	}
	while(time100[T1] <= time - 75)
	{
		motor[leftDrive] = maxPwr;
		motor[rightDrive] = maxPwr;
	}
	int midTime = time100[T1];
	while(time100[T1] <= time)
	{
		float dPwr = maxPwr * exp(midTime*0.1 - time100[T1]*0.1);
		motor[leftDrive] = dPwr;
		motor[rightDrive] = dPwr;
	}
	motor[leftDrive] = 0;
	motor[rightDrive] = 0;
}

task main()
{
	StartTask(Display);
	cosExpRamp(40 , 40.0);
}
