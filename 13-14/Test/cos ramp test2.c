#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     excel,          sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     leftDrive,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     rightDrive,    tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#include "hitechnic-accelerometer.h";
#include "ExcelDriver.h";

int min = 100; //arbitrary number greater than 0 for initialization
int max = -100; //arbitrary num < 0 for init
bool hit = false;
float time = 0;
float timeArr[500];
float powerArr[500];
/*	int excel_x_raw = 0;
	int excel_y_raw = 0;
	int excel_z_raw = 0;
	float excel_x = 0.0;
	float excel_y = 0.0;
	float excel_z = 0.0;
	const float GRAVY = 4.903325; //cm/s^2
	float y = 0.0;                // create and set 'y' to 0.0
	float LCD_width = 100.0;      // create and set 'LCD_width' to 100.0 (width of NXT LCD in pixels)
*/
/*task yValue()
{
	while(true)
	{
		HTACreadAllAxes(excel,excel_x_raw,excel_y_raw,excel_z_raw); // calculate y-coordinate of pixel to draw
		excel_y = excel_y_raw;
		excel_z = excel_z_raw;
		excel_x = excel_x_raw;
		eraseDisplay();
		nxtDisplayString(1,"x: %d", excel_x*GRAVY);
		nxtDisplayString(2,"y: %d", excel_y*GRAVY);
		nxtDisplayString(3,"z: %d", excel_z*GRAVY);
		wait1Msec(25);
	}
}

task Display()
{
	while(true)
 	{
		nxtDrawLine(0, 31, 99, 31);   // draw a line across the center of the LCD
 		excel_y = excel_y_raw*GRAVY;

		for(int x = 0; x < 100; x++)  // loop from 0 to 99
		{
		  HTACreadAllAxes(excel,excel_x_raw,excel_y_raw,excel_z_raw); // calculate y-coordinate of pixel to draw
		  excel_y = excel_y_raw*GRAVY;

		  if(abs(excel_y) > 3)
		  {
		  	if(excel_y > 0)
		  	/*{
		  		PlayTone(500,1);
		  	}
		  	else
		  	{
		  		PlayTone(300,1);
		  	}*/
		  	/*PlayTone(excel_y*5.0+300,1);
		  }
		  nxtSetPixel(x, 0.5*excel_y + 31);                   // draw pixel at (x, y+31)
		}
		eraseDisplay();
	}
}*/


task Graph()
{
	while(true)
	{

		nxtDrawLine(0, 31, 99, 31);   // draw a line across the center of the LCD

		for(int x = 0; x < 1000; x++)  // loop from 0 to 99
		{
			updateExcel();
			nxtSetPixel(x, excel_y*20.0 + 31);
		}
		eraseDisplay();
	}
}


task Values()
{
	while(true)
	{
		updateExcel();
		displayValues();
	}
}


task FindMaximum() //time in 100-Msec
{
	ClearTimer(T2);

	while(time100[T2] < time*0.2)
	{} //do nothing
	while(time100[T2] < time*0.8)
	{
		updateExcel();
		if(excel_y > max)
		{
			max = excel_y;
		}
		if(excel_y > 8) //threshold
		{
			PlayTone(440,1);
			hit = true;
		}
	}
	while(true)
	{
		nxtDisplayString(1,"max: %d", max);
		if(hit)
		{
			nxtDisplayString(2,"hit: true");
		}
		else
		{
			nxtDisplayString(2,"hit: false");
		}
	}
}


task FindMinimum() //time in 100-Msec
{
	ClearTimer(T2);

	while(time100[T2] < time*0.2)
	{} //do nothing
	while(time100[T2] < time*0.8)
	{
		updateExcel();
		if(excel_y < min)
		{
			min = excel_y;
		}
		if(excel_y < -8) //threshold
		{
			PlayTone(440,1);
			hit = true;
		}
	}
	while(true)
	{
		nxtDisplayString(1,"min: %d", min);
		if(hit)
		{
			nxtDisplayString(2,"hit: true");
		}
		else
		{
			nxtDisplayString(2,"hit: false");
		}
	}
}


void cosRampMove(float maxPwr, float totTime)
{
	float firstPwr = 0.0;
	float secondPwr = 0.0;

	float amplitude = 0.5*maxPwr;
	float currTime = 0.0;
	float period = PI/(totTime*0.75);
	float horizShift = (totTime*0.75)/4.0;
	int index = 0;

	ClearTimer(T1);

	while(time100[T1] <= totTime/4.0)
	{
		firstPwr = maxPwr;
		/*motor[leftDrive] = firstPwr;
		motor[rightDrive] = firstPwr;*/
	}
	while(time100[T1] <= totTime)
	{
		currTime = time100[T1];

		secondPwr = amplitude*cos(period*(currTime - horizShift))+amplitude;

		timeArr[index] = currTime;
		powerArr[index] = secondPwr;
		index++;

		/*motor[leftDrive] = secondPwr;
		motor[rightDrive] = secondPwr;*/
	}

	motor[leftDrive] = 0;
	motor[rightDrive] = 0;
}


task DisplayTimePwr()
{
	int currIndexMin = 0;
	int count = 0;
	for(int line = 1; line <= 8; line++)
	{
		nxtDisplayString(line,"%f,%f",timeArr[currIndexMin+count],powerArr[currIndexMin+count]);
		count++;
	}
	if(nNxtButtonPressed == 1) //right arrow
	{

		for(int line = 1; line <= 8; line++)
		{
		nxtDisplayString(line,"%f,%f",timeArr[currIndexMin+count],powerArr[currIndexMin+count]);
		count++;
		}
	}
	else if(nNxtButtonPressed == 2) //left arrow
	{
		if(count >= 0)
		{
			for(int line = 1; line <= 8; line++)
			{
			nxtDisplayString(line,"%f,%f",timeArr[currIndexMin+count],powerArr[currIndexMin+count]);
			count--;
			}
		}
	}
}


task main()
{
	time = 15;
	/*initializeExcel();
	//StartTask(Graph);
	StartTask(Values);
	//StartTask(Display);
	//StartTask(yValue);
	//StartTask(FindMinimum);
	StartTask(FindMaximum);*/
	cosRampMove(100.0,time);
	StartTask(DisplayTimePwr);
	while(true){};
}
