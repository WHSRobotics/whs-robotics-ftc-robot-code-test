#pragma config(Motor,  motorA,          driveLeft,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          driveRight,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float INCH_ENCODERVALUE = 114.591559; //number of encoder values in one inch forward for a 4 inch wheel
																						//(number of encoder values in one rotation[1440])/(wheel diameter[4]*pi[3.14...])
const float PWR_ADJUST = 7.355;//3.9 //7.5
float leftEncoderPrev = 0.0;
float rightEncoderPrev = 0.0;
float leftEncoderCurr = 0.0;
float rightEncoderCurr = 0.0;
float leftEncoderDiff = 0.0;
float rightEncoderDiff = 0.0;
float leftEncoderRate = 0.0;
float rightEncoderRate = 0.0;
float leftEncoderError = 0.0;
float rightEncoderError = 0.0;
const float CHANGE_AVG_RATE_RUN = 0.68;
const float CHANGE_AVG_RATE_SLOW = 0.3;
const float THRESHOLD = -0.04;//-0.16; //-.04 //-0.08
const float TIME_INTERVAL = 100.0; //magic numish

void stopDriveTrain()
{
  motor[driveLeft] = 0;
	motor[driveRight] = 0;
}

void moveStraight(float distanceInches, int pwr)
{
	float targetDistance = distanceInches * INCH_ENCODERVALUE;
	float pwrDriveLeft = pwr;
	float pwrDriveRight = pwr;

	nMotorEncoder[driveLeft] = 0;
	nMotorEncoder[driveRight] = 0;

	nMotorEncoderTarget[driveLeft] = targetDistance;
	nMotorEncoderTarget[driveRight] = targetDistance;

	motor[driveLeft] = pwrDriveLeft;
	motor[driveRight] = pwrDriveRight;

	wait10Msec(100);

  ClearTimer(T1);
	while(nMotorRunState[driveLeft] != runStateIdle && nMotorRunState[driveRight] != runStateIdle)
	{
    ////while encoders still have not reached their target
    if(time1[T1] >= TIME_INTERVAL) //if 100 Msec have passed
    {
      //get both encoder values
	    leftEncoderCurr = nMotorEncoder[driveLeft];
	    rightEncoderCurr = nMotorEncoder[driveRight];

	    leftEncoderDiff = leftEncoderCurr - leftEncoderPrev;
	    rightEncoderDiff = rightEncoderCurr - rightEncoderPrev;

	    //calculate encoder counts per 100 Msec for both encoders
	    leftEncoderRate = leftEncoderDiff / TIME_INTERVAL;
	    rightEncoderRate = rightEncoderDiff / TIME_INTERVAL;

	    //calculate error between current rates and avg rates
	    if(nMotorRunState[driveLeft] == runStateRunning && nMotorRunState[driveRight] == runStateRunning)
	    {
	    	leftEncoderError = leftEncoderRate - CHANGE_AVG_RATE_RUN;
	    	rightEncoderError = rightEncoderRate - CHANGE_AVG_RATE_RUN;
	  	}
	  	else if(nMotorRunState[driveLeft] == runStateHoldPosition && nMotorRunState[driveRight] == runStateHoldPosition)
	  	{
	  		leftEncoderError = leftEncoderRate - CHANGE_AVG_RATE_SLOW;
	    	rightEncoderError = rightEncoderRate - CHANGE_AVG_RATE_SLOW;
	  	}

	    if(leftEncoderError < THRESHOLD || rightEncoderError < THRESHOLD)
	    {
	      //if current rates are significantly different from average
	      //(the robot is ramming something else)

	      //back up at full power for 500 Msec
	    	PlayTone(440,500);
	      motor[driveLeft] = -100;
	      motor[driveRight] = -100;


	      wait1Msec(500);
	      stopDriveTrain();

	    }

	    //reset timers and encoders
	    ClearTimer(T1);

	    leftEncoderPrev = leftEncoderCurr;
	    rightEncoderPrev = rightEncoderCurr;

	    break;
	  }
	}
	stopDriveTrain();
}

void testMovie(float distanceInches, int pwr)
{
	float targetDistance = distanceInches*INCH_ENCODERVALUE;
	float pwrDriveLeft = pwr;
	float pwrDriveRight = pwr;

	float changeSumLeft = 0.0;
	float changeSumRight = 0.0;
	float errorSumLeft = 0.0;
	float errorSumRight = 0.0;
	float count = 0.0;

	nMotorEncoder[driveLeft] = 0;
	nMotorEncoder[driveRight] = 0;

	nMotorEncoderTarget[driveLeft] = targetDistance;
	nMotorEncoderTarget[driveRight] = targetDistance;

	motor[driveLeft] = pwrDriveLeft;
	motor[driveRight] = pwrDriveRight;

  ClearTimer(T1);
  while(true)
  {
	while(nMotorRunState[driveLeft] != runStateIdle && nMotorRunState[driveRight] != runStateIdle)
	{
    ////while encoders still have not reached their target

if(nMotorRunState[driveLeft] == runStateHoldPosition && nMotorRunState[driveRight] == runStateHoldPosition)
	{
    if(time1[T1] >= TIME_INTERVAL) //if 100 Msec have passed
    {
      //get both encoder values
	    leftEncoderCurr = nMotorEncoder[driveLeft];
	    rightEncoderCurr = nMotorEncoder[driveRight];

	    leftEncoderDiff = leftEncoderCurr - leftEncoderPrev;
	    rightEncoderDiff = rightEncoderCurr - rightEncoderPrev;

	    //calculate encoder counts per 100 Msec for both encoders
	    leftEncoderRate = leftEncoderDiff / TIME_INTERVAL;
	    rightEncoderRate = rightEncoderDiff / TIME_INTERVAL;

	    //calculate error between current rates and avg rates
	    leftEncoderError = leftEncoderRate - CHANGE_AVG_RATE_RUN;
	    rightEncoderError = rightEncoderRate - CHANGE_AVG_RATE_RUN;

	    changeSumLeft += leftEncoderRate;
	    changeSumRight += rightEncoderRate;
	    errorSumLeft += leftEncoderError;
	    errorSumRight += rightEncoderError;

	    //reset timers and encoders
	    ClearTimer(T1);

	    leftEncoderPrev = leftEncoderCurr;
	    rightEncoderPrev = rightEncoderCurr;

	    count += 1.0;
	  }
	}
}

	/*changeSumLeft = changeSumLeft / count;
	changeSumRight = changeSumRight / count;
	errorSumLeft = errorSumLeft / count;
	errorSumRight = errorSumRight / count;*/
	nxtDisplayString(1, "L Change: %f", changeSumLeft);
	nxtDisplayString(2, "L Error: %f", errorSumLeft);
	nxtDisplayString(3, "R Change: %f", changeSumRight);
	nxtDisplayString(4, "R Error: %f", errorSumRight);
	nxtDisplayString(5, "count: %f", count);
	}
	stopDriveTrain();
}


task main()
{
	testMovie(6,100);
	//moveStraight(9001, 50);
}
